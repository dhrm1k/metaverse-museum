<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Ghibli Museum</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            text-align: center;
        }
        #instructions.hidden {
            display: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-top: -10px;
            margin-left: -10px;
            color: white;
            font-size: 20px;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Click to start instructions -->
    <div id="instructions">
        <h1>Three.js Ghibli Museum</h1>
        <p>Click to start</p>
        <p>WASD to move, Mouse to look</p>
        <p>SPACE to jump, ESC to release cursor</p>
    </div>
    
    <!-- Crosshair -->
    <div id="crosshair">+</div>

    <script type="module">
        // Import Three.js from CDN
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

        // Basic setup: Scene, Camera, Renderer
        // -----------------------------------------------
        // 1. Create scene - this holds all objects, lights, etc.
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x91d5ff); // Ghibli sky blue for exterior windows
        scene.fog = new THREE.Fog(0x91d5ff, 50, 100); // Reduced fog for indoor setting

        // 2. Create camera - player's viewpoint
        const camera = new THREE.PerspectiveCamera(
            75, // Field of view
            window.innerWidth / window.innerHeight, // Aspect ratio
            0.1, // Near clipping plane
            1000 // Far clipping plane
        );
        
        // 3. Create renderer - draws everything to the screen
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.body.appendChild(renderer.domElement);
        
        // Create the camera rig system for proper controls
        const cameraYaw = new THREE.Object3D(); // Horizontal rotation (body)
        const cameraPitch = new THREE.Object3D(); // Vertical rotation (head)

        // Position the camera rig at player height
        cameraYaw.position.y = 1.6; // Eye level height

        // Set up the hierarchy
        scene.add(cameraYaw);
        cameraYaw.add(cameraPitch);
        cameraPitch.add(camera);

        // Textures
        // -----------------------------------------------
        const textureLoader = new THREE.TextureLoader();
        
        const floorTexture = textureLoader.load('https://i.imgur.com/PxYjT5d.jpg');
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(10, 10);
        
        const wallTexture = textureLoader.load('https://i.imgur.com/w1y3qXb.jpg');
        wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.repeat.set(2, 1);
        
        const ceilingTexture = textureLoader.load('https://i.imgur.com/jD2CSvF.jpg');
        ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
        ceilingTexture.repeat.set(10, 10);

        const paintingFrameTexture = textureLoader.load('https://i.imgur.com/VDKS19Y.jpg');
        
        // Main Exhibition Room and Connected Galleries
        // -----------------------------------------------
        const rooms = [];
        const allWalls = [];
        const allObjects = [];
        
        function createRoom(centerX, centerZ, width, depth, height, name) {
            const room = {
                name: name,
                walls: [],
                ceiling: null,
                floor: null,
                lights: []
            };
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(width, depth);
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: floorTexture,
                roughness: 0.8,
                color: 0xFAF0E6  // Light warm color for wooden floor
            });
            
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(centerX, 0, centerZ);
            floor.receiveShadow = true;
            scene.add(floor);
            room.floor = floor;
            
            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(width, depth);
            const ceilingMaterial = new THREE.MeshStandardMaterial({
                map: ceilingTexture,
                roughness: 0.9,
                color: 0xF5F5F5  // White ceiling
            });
            
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(centerX, height, centerZ);
            ceiling.receiveShadow = true;
            scene.add(ceiling);
            room.ceiling = ceiling;
            
            // Create walls (only where there are no doorways)
            // Helper to determine if there's a doorway at a specific position
            function hasDoorway(wallX, wallZ, isVertical) {
                // Define doorways between rooms
                const doorways = [
                    { from: { x: 0, z: -10 }, to: { x: 0, z: 0 }, width: 3 },  // Main entrance to lobby
                    { from: { x: -15, z: 0 }, to: { x: -5, z: 0 }, width: 3 },  // Lobby to West Gallery
                    { from: { x: 5, z: 0 }, to: { x: 15, z: 0 }, width: 3 },    // Lobby to East Gallery
                    { from: { x: 0, z: 0 }, to: { x: 0, z: 10 }, width: 3 }     // Lobby to North Gallery
                ];
                
                for (let doorway of doorways) {
                    if (isVertical) {  // North-South walls
                        // Check if wall is along a doorway's x-coordinate ± width/2
                        if (Math.abs(wallX - doorway.from.x) < 1.5 && 
                            ((wallZ >= doorway.from.z && wallZ <= doorway.to.z) || 
                             (wallZ <= doorway.from.z && wallZ >= doorway.to.z))) {
                            return true;
                        }
                    } else {  // East-West walls
                        // Check if wall is along a doorway's z-coordinate ± width/2
                        if (Math.abs(wallZ - doorway.from.z) < 1.5 && 
                            ((wallX >= doorway.from.x && wallX <= doorway.to.x) || 
                             (wallX <= doorway.from.x && wallX >= doorway.to.x))) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // Calculate wall segments with doorway gaps
            const halfWidth = width / 2;
            const halfDepth = depth / 2;
            
            // North Wall (with check for doorway)
            if (!hasDoorway(centerX, centerZ - halfDepth, false)) {
                const northWall = createWall(
                    centerX, centerZ - halfDepth, 
                    width, height, 0.5, 
                    wallTexture, 0xE6E6FA  // Light color for interior walls
                );
                room.walls.push(northWall);
                allWalls.push(northWall);
            } else {
                // Create wall segments on either side of the doorway
                const doorWidth = 3;
                const leftWidth = (width - doorWidth) / 2;
                const rightWidth = (width - doorWidth) / 2;
                
                if (leftWidth > 0) {
                    const leftWall = createWall(
                        centerX - doorWidth/2 - leftWidth/2, centerZ - halfDepth,
                        leftWidth, height, 0.5,
                        wallTexture, 0xE6E6FA
                    );
                    room.walls.push(leftWall);
                    allWalls.push(leftWall);
                }
                
                if (rightWidth > 0) {
                    const rightWall = createWall(
                        centerX + doorWidth/2 + rightWidth/2, centerZ - halfDepth,
                        rightWidth, height, 0.5,
                        wallTexture, 0xE6E6FA
                    );
                    room.walls.push(rightWall);
                    allWalls.push(rightWall);
                }
            }
            
            // South Wall (with check for doorway)
            if (!hasDoorway(centerX, centerZ + halfDepth, false)) {
                const southWall = createWall(
                    centerX, centerZ + halfDepth, 
                    width, height, 0.5, 
                    wallTexture, 0xE6E6FA
                );
                room.walls.push(southWall);
                allWalls.push(southWall);
            } else {
                // Create wall segments on either side of the doorway
                const doorWidth = 3;
                const leftWidth = (width - doorWidth) / 2;
                const rightWidth = (width - doorWidth) / 2;
                
                if (leftWidth > 0) {
                    const leftWall = createWall(
                        centerX - doorWidth/2 - leftWidth/2, centerZ + halfDepth,
                        leftWidth, height, 0.5,
                        wallTexture, 0xE6E6FA
                    );
                    room.walls.push(leftWall);
                    allWalls.push(leftWall);
                }
                
                if (rightWidth > 0) {
                    const rightWall = createWall(
                        centerX + doorWidth/2 + rightWidth/2, centerZ + halfDepth,
                        rightWidth, height, 0.5,
                        wallTexture, 0xE6E6FA
                    );
                    room.walls.push(rightWall);
                    allWalls.push(rightWall);
                }
            }
            
            // East Wall (with check for doorway)
            if (!hasDoorway(centerX + halfWidth, centerZ, true)) {
                const eastWall = createWall(
                    centerX + halfWidth, centerZ, 
                    0.5, height, depth, 
                    wallTexture, 0xF0E68C  // Light yellow for side walls
                );
                room.walls.push(eastWall);
                allWalls.push(eastWall);
            } else {
                // Create wall segments on either side of the doorway
                const doorWidth = 3;
                const topDepth = (depth - doorWidth) / 2;
                const bottomDepth = (depth - doorWidth) / 2;
                
                if (topDepth > 0) {
                    const topWall = createWall(
                        centerX + halfWidth, centerZ - doorWidth/2 - topDepth/2,
                        0.5, height, topDepth,
                        wallTexture, 0xF0E68C
                    );
                    room.walls.push(topWall);
                    allWalls.push(topWall);
                }
                
                if (bottomDepth > 0) {
                    const bottomWall = createWall(
                        centerX + halfWidth, centerZ + doorWidth/2 + bottomDepth/2,
                        0.5, height, bottomDepth,
                        wallTexture, 0xF0E68C
                    );
                    room.walls.push(bottomWall);
                    allWalls.push(bottomWall);
                }
            }
            
            // West Wall (with check for doorway)
            if (!hasDoorway(centerX - halfWidth, centerZ, true)) {
                const westWall = createWall(
                    centerX - halfWidth, centerZ, 
                    0.5, height, depth, 
                    wallTexture, 0xF0E68C
                );
                room.walls.push(westWall);
                allWalls.push(westWall);
            } else {
                // Create wall segments on either side of the doorway
                const doorWidth = 3;
                const topDepth = (depth - doorWidth) / 2;
                const bottomDepth = (depth - doorWidth) / 2;
                
                if (topDepth > 0) {
                    const topWall = createWall(
                        centerX - halfWidth, centerZ - doorWidth/2 - topDepth/2,
                        0.5, height, topDepth,
                        wallTexture, 0xF0E68C
                    );
                    room.walls.push(topWall);
                    allWalls.push(topWall);
                }
                
                if (bottomDepth > 0) {
                    const bottomWall = createWall(
                        centerX - halfWidth, centerZ + doorWidth/2 + bottomDepth/2,
                        0.5, height, bottomDepth,
                        wallTexture, 0xF0E68C
                    );
                    room.walls.push(bottomWall);
                    allWalls.push(bottomWall);
                }
            }
            
            // Add ceiling lights
            const lightCount = Math.floor((width * depth) / 40); // One light per 40 square units
            for (let i = 0; i < lightCount; i++) {
                // Position lights in a grid pattern
                const cols = Math.ceil(Math.sqrt(lightCount));
                const rows = Math.ceil(lightCount / cols);
                
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                const lightX = centerX - width/2 + width * (col + 0.5) / cols;
                const lightZ = centerZ - depth/2 + depth * (row + 0.5) / rows;
                
                // Create a ceiling light
                const light = createCeilingLight(lightX, height - 0.05, lightZ);
                room.lights.push(light);
            }
            
            return room;
        }
        
        // Create ceiling light
        function createCeilingLight(x, y, z) {
            // Light fixture
            const fixtureGeometry = new THREE.BoxGeometry(1, 0.1, 1);
            const fixtureMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFE0,
                emissiveIntensity: 0.2
            });
            
            const fixture = new THREE.Mesh(fixtureGeometry, fixtureMaterial);
            fixture.position.set(x, y, z);
            scene.add(fixture);
            
            // Add point light
            const light = new THREE.PointLight(0xFFFFE0, 0.8, 15);
            light.position.set(x, y - 0.1, z);
            light.castShadow = true;
            light.shadow.mapSize.width = 512;
            light.shadow.mapSize.height = 512;
            scene.add(light);
            
            return { fixture, light };
        }
        
        // Wall Creation Helper Function
        // -----------------------------------------------
        function createWall(x, z, width, height, depth, texture, color) {
            const wallGeometry = new THREE.BoxGeometry(width, height, depth);
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                color: color,
                roughness: 0.7
            });
            
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(x, height / 2, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            
            // Add wall to scene
            scene.add(wall);
            return wall;
        }
        
        // Create museum rooms (with 4m high ceilings)
        // Entrance Room
        rooms.push(createRoom(0, -15, 20, 10, 4, "Entrance"));
        
        // Main Lobby
        rooms.push(createRoom(0, 0, 20, 20, 4, "Main Lobby"));
        
        // West Gallery
        rooms.push(createRoom(-15, 0, 10, 20, 4, "West Gallery"));
        
        // East Gallery
        rooms.push(createRoom(15, 0, 10, 20, 4, "East Gallery"));
        
        // North Gallery
        rooms.push(createRoom(0, 15, 20, 10, 4, "North Gallery"));
        
        // Create display pedestals in museum
        function createPedestal(x, y, z) {
            const baseGeometry = new THREE.BoxGeometry(1.5, 0.2, 1.5);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8a8a8a });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            const columnGeometry = new THREE.BoxGeometry(0.8, 1, 0.8);
            const columnMaterial = new THREE.MeshStandardMaterial({ color: 0xd0d0d0 });
            const column = new THREE.Mesh(columnGeometry, columnMaterial);
            
            const topGeometry = new THREE.BoxGeometry(1.2, 0.15, 1.2);
            const topMaterial = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            
            base.position.set(x, y, z);
            column.position.set(x, y + 0.6, z);
            top.position.set(x, y + 1.2, z);
            
            base.castShadow = true;
            column.castShadow = true;
            top.castShadow = true;
            
            base.receiveShadow = true;
            column.receiveShadow = true;
            top.receiveShadow = true;
            
            scene.add(base);
            scene.add(column);
            scene.add(top);
            
            return [base, column, top];
        }
        
        // Add pedestals around the museum
        // Main Lobby
        const pedestals = [];
        pedestals.push(...createPedestal(-6, 0, -6));
        pedestals.push(...createPedestal(6, 0, -6));
        pedestals.push(...createPedestal(-6, 0, 6));
        pedestals.push(...createPedestal(6, 0, 6));
        
        // Add to all objects
        allObjects.push(...pedestals);
        
        // Create decorative objects on pedestals
        function createSphere(x, y, z, radius, color) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.7,
                roughness: 0.2
            });
            
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            sphere.castShadow = true;
            scene.add(sphere);
            return sphere;
        }

        // Add decorative objects with VIBRANT COLORS
        const decorations = [
            createSphere(-6, 1.7, -6, 0.4, 0xFFD700), // Bright gold
            createSphere(6, 1.7, -6, 0.4, 0x00FFFF),  // Cyan
            createSphere(-6, 1.7, 6, 0.4, 0xFF1493),  // Deep pink
            createSphere(6, 1.7, 6, 0.4, 0x00FF7F)    // Spring green
        ];
        
        allObjects.push(...decorations);
        
        // Create paintings on walls
        function createPainting(x, y, z, width, height, rotation, color) {
            // Frame
            const frameGeometry = new THREE.BoxGeometry(width + 0.2, height + 0.2, 0.1);
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                map: paintingFrameTexture,
                color: 0x8B4513
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            
            // Canvas
            const canvasGeometry = new THREE.PlaneGeometry(width, height);
            const canvasMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.5
            });
            const canvas = new THREE.Mesh(canvasGeometry, canvasMaterial);
            canvas.position.z = 0.06; // Slightly in front of the frame
            
            // Group frame and canvas
            const painting = new THREE.Group();
            painting.add(frame);
            painting.add(canvas);
            painting.position.set(x, y, z);
            painting.rotation.y = rotation;
            
            scene.add(painting);
            allObjects.push(frame);
            return painting;
        }
        
        // Add paintings to the walls in each gallery
        // West Gallery paintings (on east and west walls)
        const ghibliColors = [
            0x91d5ff, // Sky blue
            0x63a355, // Grass green
            0xffe6cc, // Light orange
            0xffeedd, // Warm light
            0xFF4500, // Orange-red
            0x9370DB, // Purple
            0x00BFFF, // Blue
            0xFFD700  // Gold
        ];
        
        // West Gallery - East Wall (faced when entering from lobby)
        for (let i = 0; i < 3; i++) {
            createPainting(
                -10, // x
                1.8,  // y
                -5 + i * 5, // z
                1.5, // width
                1.2, // height
                -Math.PI / 2, // rotation
                ghibliColors[i % ghibliColors.length]
            );
        }
        
        // West Gallery - West Wall
        for (let i = 0; i < 3; i++) {
            createPainting(
                -19.7, // x
                1.8,  // y
                -5 + i * 5, // z
                1.5, // width
                1.2, // height
                Math.PI / 2, // rotation
                ghibliColors[(i + 3) % ghibliColors.length]
            );
        }
        
        // East Gallery - West Wall (faced when entering from lobby)
        for (let i = 0; i < 3; i++) {
            createPainting(
                10, // x
                1.8,  // y
                -5 + i * 5, // z
                1.5, // width
                1.2, // height
                Math.PI / 2, // rotation
                ghibliColors[(i + 2) % ghibliColors.length]
            );
        }
        
        // East Gallery - East Wall
        for (let i = 0; i < 3; i++) {
            createPainting(
                19.7, // x
                1.8,  // y
                -5 + i * 5, // z
                1.5, // width
                1.2, // height
                -Math.PI / 2, // rotation
                ghibliColors[(i + 5) % ghibliColors.length]
            );
        }
        
        // North Gallery - North Wall
        for (let i = 0; i < 5; i++) {
            createPainting(
                -7.5 + i * 4, // x
                1.8,  // y
                19.7, // z
                1.5, // width
                1.2, // height
                Math.PI, // rotation
                ghibliColors[(i + 1) % ghibliColors.length]
            );
        }
        
        // North Gallery - East and West Walls
        createPainting(
            9.7, // x
            1.8,  // y
            15, // z
            1.5, // width
            1.2, // height
            -Math.PI / 2, // rotation
            ghibliColors[3]
        );
        
        createPainting(
            -9.7, // x
            1.8,  // y
            15, // z
            1.5, // width
            1.2, // height
            Math.PI / 2, // rotation
            ghibliColors[6]
        );
        
        // Add ambient lighting (reduced from outdoors)
        const ambientLight = new THREE.AmbientLight(0xffe6cc, 0.4);
        scene.add(ambientLight);
        
        // Add directional light (for shadows - coming from windows)
        const sunLight = new THREE.DirectionalLight(0xffeedd, 0.5);
        sunLight.position.set(10, 15, 10);
        sunLight.castShadow = true;
        sunLight.shadow.camera.far = 50;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        scene.add(sunLight);
        
        // Create Ghibli-inspired dust particles
        function createDustParticles() {
            const particlesCount = 150; // More particles for the larger space
            const particles = new THREE.Group();
            
            for (let i = 0; i < particlesCount; i++) {
                const size = Math.random() * 0.05 + 0.02;
                const geometry = new THREE.SphereGeometry(size, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: Math.random() * 0.3 + 0.2
                });
                
                const particle = new THREE.Mesh(geometry, material);
                
                // Randomly position dust in all rooms
                const room = Math.floor(Math.random() * rooms.length);
                let x, z;
                
                switch(room) {
                    case 0: // Entrance
                        x = Math.random() * 18 - 9;
                        z = Math.random() * 8 - 19;
                        break;
                    case 1: // Main Lobby
                        x = Math.random() * 18 - 9;
                        z = Math.random() * 18 - 9;
                        break;
                    case 2: // West Gallery
                        x = Math.random() * 8 - 19;
                        z = Math.random() * 18 - 9;
                        break;
                    case 3: // East Gallery
                        x = Math.random() * 8 + 11;
                        z = Math.random() * 18 - 9;
                        break;
                    case 4: // North Gallery
                        x = Math.random() * 18 - 9;
                        z = Math.random() * 8 + 11;
                        break;
                }
                
                particle.position.set(
                    x, 
                    Math.random() * 3 + 1,
                    z
                );
                
                // Random floating animation properties
                particle.userData = {
                    speed: Math.random() * 0.005 + 0.001,
                    offsetX: Math.random() * Math.PI * 2,
                    offsetY: Math.random() * Math.PI * 2,
                    amplitude: Math.random() * 0.1 + 0.05
                };
                
                particles.add(particle);
            }
            
            scene.add(particles);
            return particles;
        }
        
        const dustParticles = createDustParticles();
        
        // Controls with GRAVITY PHYSICS
        // -----------------------------------------------
        let isLocked = false;
        let keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false
        };
        
        // Physics variables
        let velocity = new THREE.Vector3(0, 0, 0);
        let gravity = -0.005;
        let jumpForce = 0.15;
        let isOnGround = true;
        
        // Event Listeners
        // -----------------------------------------------
        // 1. Click to start
        const instructions = document.getElementById('instructions');
        
        instructions.addEventListener('click', () => {
            instructions.classList.add('hidden');
            // Request pointer lock
            document.body.requestPointerLock();
        });
        
        // 2. Pointer lock change
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === document.body) {
                isLocked = true;
            } else {
                isLocked = false;
                instructions.classList.remove('hidden');
            }
        });
        
        // 3. Mouse movement for looking around
        document.addEventListener('mousemove', (event) => {
            if (!isLocked) return;
            
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            // Apply horizontal rotation to the body (yaw)
            cameraYaw.rotation.y -= movementX * 0.002;
            
            // Apply vertical rotation to the head (pitch) with constraints
            cameraPitch.rotation.x -= movementY * 0.002;
            
            // Limit vertical head movement to realistic angles (about 75 degrees up and down)
            // Limit vertical head movement to realistic angles (about 75 degrees up and down)
            cameraPitch.rotation.x = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, cameraPitch.rotation.x));
        });
        
        // 4. Keyboard controls
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyD': keys.d = true; break;
                case 'Space': keys.space = true; break;
                case 'Escape': if (isLocked) document.exitPointerLock(); break;
            }
        });
        
        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyD': keys.d = false; break;
                case 'Space': keys.space = false; break;
            }
        });
        
        // Collision detection
        function checkCollision(position) {
            // Player radius (collision cylinder)
            const playerRadius = 0.5;
            const playerHeight = 1.6;
            
            // Check wall collisions
            for (let wall of allWalls) {
                // Simple box collision test
                const wallBox = new THREE.Box3().setFromObject(wall);
                
                // Create a slightly larger box for the player position
                const playerBox = new THREE.Box3();
                playerBox.min.set(
                    position.x - playerRadius,
                    position.y,
                    position.z - playerRadius
                );
                playerBox.max.set(
                    position.x + playerRadius,
                    position.y + playerHeight,
                    position.z + playerRadius
                );
                
                if (playerBox.intersectsBox(wallBox)) {
                    return true; // Collision detected
                }
            }
            
            // Check object collisions
            for (let object of allObjects) {
                const objectBox = new THREE.Box3().setFromObject(object);
                
                // Check if player cylinder intersects with object box
                const dx = position.x - Math.max(objectBox.min.x, Math.min(position.x, objectBox.max.x));
                const dz = position.z - Math.max(objectBox.min.z, Math.min(position.z, objectBox.max.z));
                
                if (dx * dx + dz * dz < playerRadius * playerRadius &&
                    position.y < objectBox.max.y && position.y + playerHeight > objectBox.min.y) {
                    return true; // Collision detected
                }
            }
            
            return false; // No collision
        }
        
        // Animation loop
        // -----------------------------------------------
        function animate() {
            requestAnimationFrame(animate);
            
            // Only process movement if pointer is locked
            if (isLocked) {
                // Apply gravity
                velocity.y += gravity;
                
                // Jump if on ground and space pressed
                if (keys.space && isOnGround) {
                    velocity.y = jumpForce;
                    isOnGround = false;
                }
                
                // Movement speed
                const speed = 0.1;
                
                // Calculate movement direction relative to camera orientation
                const moveDirection = new THREE.Vector3(0, 0, 0);
                
                if (keys.w) moveDirection.z -= 1;
                if (keys.s) moveDirection.z += 1;
                if (keys.a) moveDirection.x -= 1;
                if (keys.d) moveDirection.x += 1;
                
                // Normalize if moving diagonally to prevent faster diagonal movement
                if (moveDirection.length() > 0) {
                    moveDirection.normalize();
                }
                
                // Create a rotation matrix from the camera's yaw rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(cameraYaw.rotation.y);
                
                // Apply the rotation to the movement direction
                moveDirection.applyMatrix4(rotationMatrix);
                
                // Scale by speed
                moveDirection.multiplyScalar(speed);
                
                // Store current position for collision detection
                const oldPosition = cameraYaw.position.clone();
                
                // Try to move horizontally (X and Z)
                const horizontalMovement = new THREE.Vector3(moveDirection.x, 0, moveDirection.z);
                cameraYaw.position.add(horizontalMovement);
                
                // If there's a collision, revert to old position
                if (checkCollision(cameraYaw.position)) {
                    cameraYaw.position.copy(oldPosition);
                    
                    // Try moving only in X direction
                    cameraYaw.position.x += moveDirection.x;
                    if (checkCollision(cameraYaw.position)) {
                        cameraYaw.position.x = oldPosition.x;
                        
                        // Try moving only in Z direction
                        cameraYaw.position.z += moveDirection.z;
                        if (checkCollision(cameraYaw.position)) {
                            cameraYaw.position.z = oldPosition.z;
                        }
                    }
                }
                
                // Apply gravity/vertical movement
                cameraYaw.position.y += velocity.y;
                
                // Check for ground collision
                if (cameraYaw.position.y < 1.6) { // Eye height
                    cameraYaw.position.y = 1.6;
                    velocity.y = 0;
                    isOnGround = true;
                }
                
                // Check for ceiling collision
                if (cameraYaw.position.y > 3.9) { // Ceiling height is 4.0
                    cameraYaw.position.y = 3.9;
                    velocity.y = 0;
                }
            }
            
            // Animate dust particles
            dustParticles.children.forEach(particle => {
                const { speed, offsetX, offsetY, amplitude } = particle.userData;
                
                // Gentle floating motion
                particle.position.y += Math.sin(Date.now() * speed + offsetY) * 0.001;
                particle.position.x += Math.sin(Date.now() * speed + offsetX) * 0.0005;
                particle.position.z += Math.cos(Date.now() * speed + offsetX) * 0.0005;
                
                // Reset particles that drift too far from their original position
                if (Math.abs(particle.position.y - particle.userData.originalY) > amplitude) {
                    particle.position.y = particle.userData.originalY + 
                        Math.sin(Date.now() * speed + offsetY) * amplitude;
                }
            });
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Store original y positions for dust particles
        dustParticles.children.forEach(particle => {
            particle.userData.originalY = particle.position.y;
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start animation loop
        animate();
    </script>
</body>
</html>