<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Raycasting Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="info">
        WASD or Arrow Keys to move<br>
        Mouse to look around<br>
        Click to lock/unlock mouse
    </div>

    <script>
        // Game configuration
        const config = {
            texSize: 128,         // Increased texture size for more detail
            fov: 70,              // Field of view in degrees
            movementSpeed: 0.1,   // Movement speed
            rotationSpeed: 0.03,  // Rotation speed
            maxDistance: 20,      // Maximum rendering distance
            wallHeight: 1.0,      // Standard wall height
            shadowIntensity: 0.7, // Shadow intensity (0-1)
            wallDetail: 1.0,      // Wall texture detail multiplier
            lightFalloff: 0.7,    // Light intensity falloff
            smoothShading: true,  // Enable smooth shading
            floorReflections: true // Enable floor reflections
        };

        // Main game variables
        let canvas, ctx;
        let isPointerLocked = false;
        let keys = {};
        let frameTime = 0;
        let lastTime = 0;
        let fps = 0;

        // Player state
        const player = {
            x: 2.5,
            y: 2.5,
            angle: 0,
            height: 0.5
        };

        // Map data (0 = empty, 1-9 = different wall types)
        const MAP_SIZE = 20;
        const map = [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 2, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 9, 9, 0, 1,
            1, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 5, 5, 5, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 5, 0, 5, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 5, 5, 0, 0, 1,
            1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 0, 0, 0, 1,
            1, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 7, 7, 7, 7, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 4, 6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
        ];

        // Texture storage
        const textures = [];
        const numTextures = 9;
        
        // Wall textures
        function generateTextures() {
            // Generate wall textures
            for (let i = 0; i < numTextures; i++) {
                const texture = document.createElement('canvas');
                texture.width = config.texSize;
                texture.height = config.texSize;
                const texCtx = texture.getContext('2d');
                
                // Different texture patterns based on wall type
                switch (i + 1) {
                    case 1: // Stone brick
                        drawStoneBrickTexture(texCtx, config.texSize);
                        break;
                    case 2: // Wooden panels
                        drawWoodenPanelsTexture(texCtx, config.texSize);
                        break;
                    case 3: // Concrete
                        drawConcreteTexture(texCtx, config.texSize);
                        break;
                    case 4: // Marble
                        drawMarbleTexture(texCtx, config.texSize);
                        break;
                    case 5: // Decorative pattern
                        drawDecorativeTexture(texCtx, config.texSize);
                        break;
                    case 6: // Painting/Image Demo
                        drawDemoImage(texCtx, config.texSize);
                        break;
                    case 7: // Metal panels
                        drawMetalTexture(texCtx, config.texSize);
                        break;
                    case 8: // Tile
                        drawTileTexture(texCtx, config.texSize);
                        break;
                    case 9: // Window
                        drawWindowTexture(texCtx, config.texSize);
                        break;
                }
                
                textures.push(texture);
            }
        }

        function drawStoneBrickTexture(ctx, size) {
            // Base color
            ctx.fillStyle = '#8c8c8c';
            ctx.fillRect(0, 0, size, size);
            
            // Brick pattern
            ctx.fillStyle = '#777777';
            const brickHeight = size / 4;
            const brickWidth = size / 2;
            
            for (let y = 0; y < size; y += brickHeight) {
                const offset = (Math.floor(y / brickHeight) % 2) * (brickWidth / 2);
                for (let x = 0; x < size; x += brickWidth) {
                    ctx.fillRect(x + offset, y, brickWidth - 2, brickHeight - 2);
                }
            }
            
            // Noise overlay for texture
            addNoiseOverlay(ctx, size, 0.1);
        }

        function drawWoodenPanelsTexture(ctx, size) {
            // Base wood color
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 0, size, size);
            
            // Wood grain
            const numPlanks = 4;
            const plankHeight = size / numPlanks;
            
            for (let i = 0; i < numPlanks; i++) {
                // Plank color variations
                ctx.fillStyle = `rgb(${139 + Math.random() * 20}, ${69 + Math.random() * 10}, ${19 + Math.random() * 10})`;
                ctx.fillRect(0, i * plankHeight, size, plankHeight - 1);
                
                // Grain lines
                ctx.strokeStyle = '#614126';
                ctx.lineWidth = 1;
                
                for (let j = 0; j < 5; j++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * plankHeight + Math.random() * plankHeight);
                    
                    // Wavy line for wood grain
                    for (let x = 0; x < size; x += 10) {
                        ctx.lineTo(x, i * plankHeight + Math.random() * plankHeight);
                    }
                    
                    ctx.stroke();
                }
            }
            
            // Noise overlay for texture
            addNoiseOverlay(ctx, size, 0.15);
        }

        function drawConcreteTexture(ctx, size) {
            // Base color
            ctx.fillStyle = '#a8a8a8';
            ctx.fillRect(0, 0, size, size);
            
            // Concrete speckling
            for (let i = 0; i < 1000; i++) {
                const shade = 140 + Math.random() * 60;
                ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
                const speckSize = Math.random() * 2;
                ctx.fillRect(
                    Math.random() * size,
                    Math.random() * size,
                    speckSize, speckSize
                );
            }
            
            // Add some cracks
            ctx.strokeStyle = '#909090';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                const startX = Math.random() * size;
                const startY = Math.random() * size;
                ctx.moveTo(startX, startY);
                
                let x = startX;
                let y = startY;
                
                for (let j = 0; j < 5; j++) {
                    x += (Math.random() - 0.5) * 20;
                    y += (Math.random() - 0.5) * 20;
                    ctx.lineTo(x, y);
                }
                
                ctx.stroke();
            }
        }

        function drawMarbleTexture(ctx, size) {
            // Base white color
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, size, size);
            
            // Create marble effect with noise
            const noiseCanvas = document.createElement('canvas');
            noiseCanvas.width = size;
            noiseCanvas.height = size;
            const noiseCtx = noiseCanvas.getContext('2d');
            
            // Generate perlin-like noise
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const value = Math.sin(x / 10) * Math.sin(y / 10) * 0.4 + 0.6;
                    const color = Math.floor(200 * value) + 55;
                    noiseCtx.fillStyle = `rgba(${color}, ${color}, ${color + 5}, 0.3)`;
                    noiseCtx.fillRect(x, y, 1, 1);
                }
            }
            
            // Add veins
            noiseCtx.strokeStyle = 'rgba(180, 180, 190, 0.5)';
            noiseCtx.lineWidth = 1;
            
            for (let i = 0; i < 10; i++) {
                noiseCtx.beginPath();
                let x = Math.random() * size;
                let y = Math.random() * size;
                noiseCtx.moveTo(x, y);
                
                for (let j = 0; j < 5; j++) {
                    x += (Math.random() - 0.5) * 40;
                    y += (Math.random() - 0.5) * 40;
                    noiseCtx.lineTo(x, y);
                }
                
                noiseCtx.stroke();
            }
            
            // Apply noise to the main texture
            ctx.drawImage(noiseCanvas, 0, 0);
        }

        function drawDecorativeTexture(ctx, size) {
            // Base color
            ctx.fillStyle = '#e0e0ff';
            ctx.fillRect(0, 0, size, size);
            
            // Draw fancy pattern
            ctx.fillStyle = '#c0c0ff';
            
            // Draw pattern
            const patternSize = size / 4;
            
            for (let y = 0; y < size; y += patternSize) {
                for (let x = 0; x < size; x += patternSize) {
                    // Alternating pattern
                    if ((x / patternSize + y / patternSize) % 2 === 0) {
                        ctx.fillRect(x, y, patternSize, patternSize);
                    }
                }
            }
            
            // Add decorative elements
            ctx.strokeStyle = '#9090ff';
            ctx.lineWidth = 2;
            
            // Draw a decorative border
            ctx.strokeRect(5, 5, size - 10, size - 10);
            
            // Draw a central decorative element
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 4, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 6, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawDemoImage(ctx, size) {
            // Base color - dark frame
            ctx.fillStyle = '#333333';
            ctx.fillRect(0, 0, size, size);
            
            // Inner frame
            ctx.fillStyle = '#e0e0e0';
            ctx.fillRect(size/20, size/20, size - size/10, size - size/10);
            
            // Enhanced demo image - modern landscape scene
            
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, size/2);
            skyGradient.addColorStop(0, '#1a3a8f');   // Darker blue at top
            skyGradient.addColorStop(1, '#87CEEB');   // Lighter blue at horizon
            ctx.fillStyle = skyGradient;
            ctx.fillRect(size/15, size/15, size - size/7.5, size/2);
            
            // Ground gradient
            const groundGradient = ctx.createLinearGradient(0, size/2, 0, size);
            groundGradient.addColorStop(0, '#8FBC8F');   // Light green near horizon
            groundGradient.addColorStop(1, '#3a5f3a');   // Darker green in foreground
            ctx.fillStyle = groundGradient;
            ctx.fillRect(size/15, size/2, size - size/7.5, size/2 - size/15);
            
            // Sun with glow
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(size/3, size/3.5, size/12, 0, Math.PI * 2);
            ctx.fill();
            
            // Sun glow
            const sunGlow = ctx.createRadialGradient(
                size/3, size/3.5, size/12,
                size/3, size/3.5, size/6
            );
            sunGlow.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
            sunGlow.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = sunGlow;
            ctx.beginPath();
            ctx.arc(size/3, size/3.5, size/6, 0, Math.PI * 2);
            ctx.fill();
            
            // Mountains with snow caps
            ctx.fillStyle = '#6c6c6c';
            ctx.beginPath();
            ctx.moveTo(size/15, size/2);
            ctx.lineTo(size/3, size/4);
            ctx.lineTo(size/2, size/2);
            ctx.closePath();
            ctx.fill();
            
            // Snow cap on first mountain
            ctx.fillStyle = '#f0f0f0';
            ctx.beginPath();
            ctx.moveTo(size/3 - size/15, size/4 + size/20);
            ctx.lineTo(size/3, size/4);
            ctx.lineTo(size/3 + size/15, size/4 + size/20);
            ctx.closePath();
            ctx.fill();
            
            // Second mountain
            ctx.fillStyle = '#4a4a4a';
            ctx.beginPath();
            ctx.moveTo(size/3, size/2);
            ctx.lineTo(2 * size/3, size/3);
            ctx.lineTo(size - size/15, size/2);
            ctx.closePath();
            ctx.fill();
            
            // Snow cap on second mountain
            ctx.fillStyle = '#f0f0f0';
            ctx.beginPath();
            ctx.moveTo(2 * size/3 - size/12, size/3 + size/25);
            ctx.lineTo(2 * size/3, size/3);
            ctx.lineTo(2 * size/3 + size/12, size/3 + size/25);
            ctx.closePath();
            ctx.fill();
            
            // Lake with reflection
            ctx.fillStyle = '#5f9ea0';
            ctx.beginPath();
            ctx.ellipse(size/2, size/1.5, size/4, size/12, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Lake reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.ellipse(size/2, size/1.5 - size/30, size/5, size/20, 0, 0, Math.PI);
            ctx.fill();
            
            // Trees - multiple with different sizes
            for (let i = 0; i < 5; i++) {
                const treeX = size/6 + (i * size/8);
                const treeSize = (Math.random() * 0.5 + 0.5) * (size/12);
                const treeY = size/1.8 + (Math.random() * size/20);
                
                // Tree trunk
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(treeX - size/150, treeY - treeSize, size/75, treeSize);
                
                // Tree foliage - more detailed with multiple layers
                ctx.fillStyle = '#006400';
                ctx.beginPath();
                ctx.moveTo(treeX - treeSize/1.5, treeY - treeSize * 0.2);
                ctx.lineTo(treeX, treeY - treeSize * 1.5);
                ctx.lineTo(treeX + treeSize/1.5, treeY - treeSize * 0.2);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(treeX - treeSize/1.5, treeY - treeSize * 0.5);
                ctx.lineTo(treeX, treeY - treeSize * 1.7);
                ctx.lineTo(treeX + treeSize/1.5, treeY - treeSize * 0.5);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(treeX - treeSize/1.5, treeY - treeSize * 0.8);
                ctx.lineTo(treeX, treeY - treeSize * 1.9);
                ctx.lineTo(treeX + treeSize/1.5, treeY - treeSize * 0.8);
                ctx.closePath();
                ctx.fill();
            }
            
            // Frame details
            ctx.strokeStyle = '#5A3A22';
            ctx.lineWidth = 8;
            ctx.strokeRect(size/30, size/30, size - size/15, size - size/15);
            
            // Frame corner embellishments
            const cornerSize = size/12;
            ctx.fillStyle = '#4a2a12';
            
            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(cornerSize, 0);
            ctx.lineTo(0, cornerSize);
            ctx.closePath();
            ctx.fill();
            
            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(size, 0);
            ctx.lineTo(size - cornerSize, 0);
            ctx.lineTo(size, cornerSize);
            ctx.closePath();
            ctx.fill();
            
            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(0, size);
            ctx.lineTo(cornerSize, size);
            ctx.lineTo(0, size - cornerSize);
            ctx.closePath();
            ctx.fill();
            
            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(size, size);
            ctx.lineTo(size - cornerSize, size);
            ctx.lineTo(size, size - cornerSize);
            ctx.closePath();
            ctx.fill();
            
            // Add signature in bottom right
            ctx.fillStyle = '#333';
            ctx.font = `${size/20}px cursive`;
            ctx.fillText("Claude", size - size/4, size - size/20);
        }

        function drawMetalTexture(ctx, size) {
            // Base metallic color
            const baseColor = '#A0A0A0';
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, size, size);
            
            // Add metallic panels
            const panelSize = size / 2;
            
            for (let y = 0; y < size; y += panelSize) {
                for (let x = 0; x < size; x += panelSize) {
                    // Panel edge highlight
                    ctx.fillStyle = '#B8B8B8';
                    ctx.fillRect(x + 1, y + 1, panelSize - 2, panelSize - 2);
                    
                    // Panel inner shadow
                    ctx.fillStyle = '#909090';
                    ctx.fillRect(x + 3, y + 3, panelSize - 6, panelSize - 6);
                    
                    // Panel center
                    ctx.fillStyle = baseColor;
                    ctx.fillRect(x + 5, y + 5, panelSize - 10, panelSize - 10);
                }
            }
            
            // Add bolts
            ctx.fillStyle = '#D0D0D0';
            const boltSize = size / 16;
            
            for (let y = panelSize / 2; y < size; y += panelSize) {
                for (let x = panelSize / 2; x < size; x += panelSize) {
                    ctx.beginPath();
                    ctx.arc(x, y, boltSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bolt detail
                    ctx.strokeStyle = '#808080';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x - boltSize / 2, y);
                    ctx.lineTo(x + boltSize / 2, y);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y - boltSize / 2);
                    ctx.lineTo(x, y + boltSize / 2);
                    ctx.stroke();
                }
            }
            
            // Add subtle scratch marks
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 20; i++) {
                const x1 = Math.random() * size;
                const y1 = Math.random() * size;
                const length = Math.random() * 20 + 5;
                const angle = Math.random() * Math.PI * 2;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(
                    x1 + Math.cos(angle) * length,
                    y1 + Math.sin(angle) * length
                );
                ctx.stroke();
            }
        }

        function drawTileTexture(ctx, size) {
            // Base color
            ctx.fillStyle = '#F5F5F5';
            ctx.fillRect(0, 0, size, size);
            
            // Draw tile grid
            const tileCount = 8; // Increased for more detail
            const tileSize = size / tileCount;
            
            for (let y = 0; y < tileCount; y++) {
                for (let x = 0; x < tileCount; x++) {
                    // Alternate tile colors
                    if ((x + y) % 2 === 0) {
                        ctx.fillStyle = '#E0E0E0';
                    } else {
                        ctx.fillStyle = '#F8F8F8';
                    }
                    
                    ctx.fillRect(
                        x * tileSize,
                        y * tileSize,
                        tileSize - 1,
                        tileSize - 1
                    );
                    
                    // Add tile details
                    ctx.strokeStyle = '#D0D0D0';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(
                        x * tileSize + 2,
                        y * tileSize + 2,
                        tileSize - 5,
                        tileSize - 5
                    );
                }
            }
            
            // Add subtle grout texture
            ctx.fillStyle = '#CCCCCC';
            
            for (let y = 0; y < tileCount; y++) {
                for (let x = 0; x < tileCount; x++) {
                    ctx.fillRect(
                        x * tileSize - 1,
                        y * tileSize - 1,
                        2,
                        2
                    );
                }
            }
        }

        function drawWindowTexture(ctx, size) {
            // Base window frame
            ctx.fillStyle = '#B0B0B0';
            ctx.fillRect(0, 0, size, size);
            
            // Window panes
            ctx.fillStyle = '#ADD8E6';
            
            // Create window grid (2x2)
            const margin = size / 10;
            const paneSize = (size - 3 * margin) / 2;
            
            for (let y = 0; y < 2; y++) {
                for (let x = 0; x < 2; x++) {
                    ctx.fillRect(
                        margin + x * (paneSize + margin),
                        margin + y * (paneSize + margin),
                        paneSize,
                        paneSize
                    );
                }
            }
            
            // Add window frame details
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 2;
            
            // Horizontal divider
            ctx.beginPath();
            ctx.moveTo(0, size / 2);
            ctx.lineTo(size, size / 2);
            ctx.stroke();
            
            // Vertical divider
            ctx.beginPath();
            ctx.moveTo(size / 2, 0);
            ctx.lineTo(size / 2, size);
            ctx.stroke();
            
            // Window frame outer border
            ctx.strokeRect(2, 2, size - 4, size - 4);
            
            // Add light reflection on glass
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            
            for (let i = 0; i < 2; i++) {
                const x = margin + Math.random() * paneSize;
                const y = margin + Math.random() * paneSize;
                const glareSize = Math.random() * 10 + 5;
                
                ctx.beginPath();
                ctx.arc(x, y, glareSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Add view through window - simple scene
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#87CEEB'; // Sky
            // Add view through window - simple scene
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#87CEEB'; // Sky
            for (let y = 0; y < 2; y++) {
                for (let x = 0; x < 2; x++) {
                    ctx.fillRect(
                        margin + x * (paneSize + margin) + 5,
                        margin + y * (paneSize + margin) + 5,
                        paneSize - 10,
                        paneSize / 2 - 5
                    );
                }
            }
            
            // Simple ground through window
            ctx.fillStyle = '#228B22'; // Green
            for (let y = 0; y < 2; y++) {
                for (let x = 0; x < 2; x++) {
                    ctx.fillRect(
                        margin + x * (paneSize + margin) + 5,
                        margin + y * (paneSize + margin) + paneSize / 2,
                        paneSize - 10,
                        paneSize / 2 - 5
                    );
                }
            }
            
            ctx.globalAlpha = 1.0;
        }

        // Add noise to texture for realism
        function addNoiseOverlay(ctx, size, intensity) {
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (Math.random() < intensity) {
                        const value = Math.random() * 30;
                        ctx.fillStyle = `rgba(0, 0, 0, ${value / 100})`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
        }

        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size to window size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Generate textures
            generateTextures();
            
            // Add event listeners
            document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
            
            canvas.addEventListener('click', () => {
                if (!isPointerLocked) {
                    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
                    canvas.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', lockChangeAlert, false);
            document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
            
            document.addEventListener('mousemove', handleMouseMove);
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        function lockChangeAlert() {
            if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
                isPointerLocked = true;
            } else {
                isPointerLocked = false;
            }
        }

        function handleMouseMove(e) {
            if (isPointerLocked) {
                player.angle += e.movementX * 0.003;
            }
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Main game loop
        function gameLoop(timestamp) {
            // Calculate frame time
            if (!lastTime) lastTime = timestamp;
            frameTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            fps = Math.round(1 / frameTime);
            
            // Clear screen
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Handle player movement
            handleInput();
            
            // Render view
            raycasting();
            
            // Display FPS
            displayInfo();
            
            // Continue loop
            requestAnimationFrame(gameLoop);
        }

        function handleInput() {
            const moveSpeed = config.movementSpeed;
            const rotSpeed = config.rotationSpeed;
            
            // Forward/backward movement
            if (keys['w'] || keys['arrowup']) {
                const newX = player.x + Math.cos(player.angle) * moveSpeed;
                const newY = player.y + Math.sin(player.angle) * moveSpeed;
                if (!checkCollision(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys['s'] || keys['arrowdown']) {
                const newX = player.x - Math.cos(player.angle) * moveSpeed;
                const newY = player.y - Math.sin(player.angle) * moveSpeed;
                if (!checkCollision(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            
            // Strafe left/right
            if (keys['a'] || keys['arrowleft']) {
                const newX = player.x + Math.cos(player.angle - Math.PI/2) * moveSpeed;
                const newY = player.y + Math.sin(player.angle - Math.PI/2) * moveSpeed;
                if (!checkCollision(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys['d'] || keys['arrowright']) {
                const newX = player.x + Math.cos(player.angle + Math.PI/2) * moveSpeed;
                const newY = player.y + Math.sin(player.angle + Math.PI/2) * moveSpeed;
                if (!checkCollision(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            
            // Rotation with keyboard (for testing without mouse)
            if (keys['q']) {
                player.angle -= rotSpeed;
            }
            if (keys['e']) {
                player.angle += rotSpeed;
            }
        }

        function checkCollision(x, y) {
            // Wall collision detection with small buffer around player
            const buffer = 0.2;
            const mapX = Math.floor(x);
            const mapY = Math.floor(y);
            
            // Check if position is inside a wall
            if (mapX >= 0 && mapX < MAP_SIZE && mapY >= 0 && mapY < MAP_SIZE) {
                return map[mapY * MAP_SIZE + mapX] !== 0;
            }
            
            return true; // Collide with boundaries
        }

        function raycasting() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Calculate ray parameters
            const fovRadians = config.fov * Math.PI / 180;
            const rayCount = width;
            const angleStep = fovRadians / rayCount;
            
            // Draw floor and ceiling
            ctx.fillStyle = '#111111'; // Ceiling
            ctx.fillRect(0, 0, width, height / 2);
            
            ctx.fillStyle = '#333333'; // Floor
            ctx.fillRect(0, height / 2, width, height / 2);
            
            // Cast rays for each screen column
            for (let i = 0; i < rayCount; i++) {
                // Calculate ray angle
                const rayAngle = player.angle - (fovRadians / 2) + (i * angleStep);
                
                // Normalize angle
                const normalizedAngle = rayAngle % (2 * Math.PI);
                
                // Cast ray and get wall data
                const { distance, wallType, side, texX } = castRay(normalizedAngle);
                
                // Calculate wall height based on distance (with perspective correction)
                const perpDistance = distance * Math.cos(rayAngle - player.angle);
                const wallHeight = Math.min(height, (config.wallHeight * height) / perpDistance);
                
                // Draw wall slice
                drawWallSlice(i, wallHeight, wallType - 1, side, texX);
                
                // Draw floor and ceiling (advanced rendering)
                if (config.floorReflections) {
                    drawFloorCeiling(i, wallHeight, normalizedAngle, perpDistance);
                }
            }
        }

        function castRay(angle) {
            // Ray direction
            const rayDirX = Math.cos(angle);
            const rayDirY = Math.sin(angle);
            
            // Player position in map coordinates
            const mapX = Math.floor(player.x);
            const mapY = Math.floor(player.y);
            
            // Distance from current position to next grid line
            let deltaDistX = Math.abs(1 / rayDirX);
            let deltaDistY = Math.abs(1 / rayDirY);
            
            // Step direction
            const stepX = rayDirX < 0 ? -1 : 1;
            const stepY = rayDirY < 0 ? -1 : 1;
            
            // Initial side distance
            let sideDistX = rayDirX < 0 
                ? (player.x - mapX) * deltaDistX 
                : (mapX + 1 - player.x) * deltaDistX;
            
            let sideDistY = rayDirY < 0 
                ? (player.y - mapY) * deltaDistY 
                : (mapY + 1 - player.y) * deltaDistY;
            
            // DDA algorithm for ray casting
            let hit = false;
            let side = 0; // 0 for X side, 1 for Y side
            let currentMapX = mapX;
            let currentMapY = mapY;
            let wallType = 0;
            
            while (!hit && 
                   Math.sqrt(Math.pow(currentMapX - player.x, 2) + 
                            Math.pow(currentMapY - player.y, 2)) < config.maxDistance) {
                
                // Jump to next map square
                if (sideDistX < sideDistY) {
                    sideDistX += deltaDistX;
                    currentMapX += stepX;
                    side = 0;
                } else {
                    sideDistY += deltaDistY;
                    currentMapY += stepY;
                    side = 1;
                }
                
                // Check for wall hit
                if (currentMapX >= 0 && currentMapX < MAP_SIZE && 
                    currentMapY >= 0 && currentMapY < MAP_SIZE) {
                    
                    wallType = map[currentMapY * MAP_SIZE + currentMapX];
                    if (wallType > 0) {
                        hit = true;
                    }
                } else {
                    // Map boundary hit
                    hit = true;
                    wallType = 1; // Default wall
                }
            }
            
            // Calculate distance to the wall
            let wallDist;
            let texX;
            
            if (side === 0) {
                wallDist = (currentMapX - player.x + (1 - stepX) / 2) / rayDirX;
                texX = player.y + wallDist * rayDirY;
            } else {
                wallDist = (currentMapY - player.y + (1 - stepY) / 2) / rayDirY;
                texX = player.x + wallDist * rayDirX;
            }
            
            // Normalize texX to [0, 1] range
            texX = texX % 1;
            if (texX < 0) texX += 1;
            
            return {
                distance: wallDist,
                wallType: wallType,
                side: side,
                texX: texX
            };
        }

        function drawWallSlice(screenX, wallHeight, textureIndex, side, texX) {
            const height = canvas.height;
            
            // Calculate wall position on screen
            const wallStart = Math.max(0, (height - wallHeight) / 2);
            const wallEnd = Math.min(height, (height + wallHeight) / 2);
            
            // Get texture
            const texture = textures[textureIndex] || textures[0];
            
            // Map texture X coordinate to texture size
            const texPosX = Math.floor(texX * config.texSize);
            
            // Get texture column
            const column = texture.getContext('2d').getImageData(texPosX, 0, 1, config.texSize).data;
            
            // Create wall image data
            const wallSlice = ctx.createImageData(1, wallEnd - wallStart);
            
            // Apply shadow based on wall side (E/W vs N/S)
            const shadowFactor = side === 1 ? config.shadowIntensity : 1.0;
            
            // Apply light falloff with distance (simple linear falloff)
            const wallDistance = wallHeight / (config.wallHeight * canvas.height);
            const distanceFactor = config.lightFalloff * wallDistance + (1 - config.lightFalloff);
            
            // Fill wall slice with texture
            for (let y = 0; y < wallEnd - wallStart; y++) {
                // Map screen Y to texture Y
                const texY = Math.floor((y / (wallEnd - wallStart)) * config.texSize);
                
                // Get texture pixel
                const texPos = texY * 4; // * 4 for RGBA
                
                // Apply lighting and shading
                const r = column[texPos] * shadowFactor * distanceFactor;
                const g = column[texPos + 1] * shadowFactor * distanceFactor;
                const b = column[texPos + 2] * shadowFactor * distanceFactor;
                const a = column[texPos + 3];
                
                // Set pixel in wall slice
                const pos = y * 4;
                wallSlice.data[pos] = r;
                wallSlice.data[pos + 1] = g;
                wallSlice.data[pos + 2] = b;
                wallSlice.data[pos + 3] = a;
            }
            
            // Draw wall slice
            ctx.putImageData(wallSlice, screenX, wallStart);
        }

        function drawFloorCeiling(screenX, wallHeight, rayAngle, perpDistance) {
            const height = canvas.height;
            
            // Calculate wall position on screen
            const wallStart = Math.max(0, (height - wallHeight) / 2);
            const wallEnd = Math.min(height, (height + wallHeight) / 2);
            
            // Draw floor and ceiling with basic shading
            for (let y = wallEnd; y < height; y++) {
                // Calculate floor ray parameters
                const currentDist = height / (2.0 * y - height);
                const weight = currentDist / perpDistance;
                
                // Floor point
                const floorX = weight * Math.cos(rayAngle) + player.x;
                const floorY = weight * Math.sin(rayAngle) + player.y;
                
                // Get floor texture position
                const floorTexX = Math.floor(floorX * config.texSize) % config.texSize;
                const floorTexY = Math.floor(floorY * config.texSize) % config.texSize;
                
                // Simple floor coloring based on distance
                const r = 50 - Math.min(40, currentDist * 2);
                const g = 50 - Math.min(40, currentDist * 2);
                const b = 50 - Math.min(40, currentDist * 2);
                
                // Draw floor pixel
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(screenX, y, 1, 1);
                
                // Draw ceiling pixel (mirrored)
                const ceilingY = height - y;
                
                if (ceilingY >= 0 && ceilingY < wallStart) {
                    const r2 = 20 - Math.min(15, currentDist);
                    const g2 = 20 - Math.min(15, currentDist);
                    const b2 = 30 - Math.min(25, currentDist);
                    
                    ctx.fillStyle = `rgb(${r2}, ${g2}, ${b2})`;
                    ctx.fillRect(screenX, ceilingY, 1, 1);
                }
            }
        }

        function displayInfo() {
            const infoDiv = document.getElementById('info');
            infoDiv.innerHTML = `
                WASD or Arrow Keys to move<br>
                Mouse to look around<br>
                Click to lock/unlock mouse<br>
                FPS: ${fps}<br>
                X: ${player.x.toFixed(2)}, Y: ${player.y.toFixed(2)}
            `;
        }

        // Start the game
        window.onload = init;
    </script>
</body>
</html>